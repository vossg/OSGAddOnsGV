// This file has been generated by Py++.


// PyOpenSG is (C) Copyright 2005-2009 by Allen Bierbaum
//
// This file is part of PyOpenSG.
//
// PyOpenSG is free software; you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation; either version 2 of the License, or (at your option)
// any later version.
//
// PyOpenSG is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
// FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
// more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#if __GNUC__ >= 4 || __GNUC_MINOR__ >=3
#pragma GCC diagnostic warning "-Wold-style-cast"
#pragma GCC diagnostic warning "-Wunused-local-typedefs"
#endif
#if WIN32
#pragma warning(disable : 4267)
#pragma warning(disable : 4344)
#endif

#include "boost/python.hpp"
#include "OSGSystem_mainheader.h"
#include "OsgPtrHelpers.h"
#include "boost/python/suite/indexing/map_indexing_suite.hpp"
#include "boost/python/suite/indexing/vector_indexing_suite.hpp"
#include "ImageFileType.pypp.hpp"

using namespace std;
namespace bp = boost::python;

struct ImageFileType_wrapper : OSG::ImageFileType, bp::wrapper< OSG::ImageFileType > {

    ImageFileType_wrapper(::OSG::Char8 const * mimeType, ::OSG::Char8 const * * suffixArray, ::OSG::UInt16 suffixByteCount, ::OSG::UInt32 flags=::OSG::UInt32(::OSG::ImageFileType::OSG_READ_SUPPORTED) )
    : OSG::ImageFileType( mimeType, suffixArray, suffixByteCount, flags )
      , bp::wrapper< OSG::ImageFileType >(){
        // constructor
    
    }

    virtual ::OSG::UInt64 maxBufferSize( ::OSG::Image const * pImage ) {
        if( bp::override func_maxBufferSize = this->get_override( "maxBufferSize" ) )
            return func_maxBufferSize( boost::python::ptr(pImage) );
        else{
            return this->OSG::ImageFileType::maxBufferSize( boost::python::ptr(pImage) );
        }
    }
    
    ::OSG::UInt64 default_maxBufferSize( ::OSG::Image const * pImage ) {
        return OSG::ImageFileType::maxBufferSize( boost::python::ptr(pImage) );
    }

    virtual ::OSG::ImageBlockAccessorPtr open( ::OSG::Char8 const * fileName ) {
        if( bp::override func_open = this->get_override( "open" ) )
            return func_open( fileName );
        else{
            return this->OSG::ImageFileType::open( fileName );
        }
    }
    
    ::OSG::ImageBlockAccessorPtr default_open( ::OSG::Char8 const * fileName ) {
        return OSG::ImageFileType::open( fileName );
    }

    virtual bool read( ::OSG::Image * pImage, ::OSG::Char8 const * fileName ) {
        if( bp::override func_read = this->get_override( "read" ) )
            return func_read( boost::python::ptr(pImage), fileName );
        else{
            return this->OSG::ImageFileType::read( boost::python::ptr(pImage), fileName );
        }
    }
    
    bool default_read( ::OSG::Image * pImage, ::OSG::Char8 const * fileName ) {
        return OSG::ImageFileType::read( boost::python::ptr(pImage), fileName );
    }

    virtual bool read( ::OSG::Image * pImage, ::std::istream & is, ::std::string const & mimetype ) {
        if( bp::override func_read = this->get_override( "read" ) )
            return func_read( boost::python::ptr(pImage), boost::ref(is), mimetype );
        else{
            return this->OSG::ImageFileType::read( boost::python::ptr(pImage), boost::ref(is), mimetype );
        }
    }
    
    bool default_read( ::OSG::Image * pImage, ::std::istream & is, ::std::string const & mimetype ) {
        return OSG::ImageFileType::read( boost::python::ptr(pImage), boost::ref(is), mimetype );
    }

    virtual ::OSG::UInt64 restoreData( ::OSG::Image * pImage, ::OSG::UChar8 const * buffer, ::OSG::Int32 memSize=-0x00000000000000001 ) const  {
        if( bp::override func_restoreData = this->get_override( "restoreData" ) )
            return func_restoreData( boost::python::ptr(pImage), buffer, memSize );
        else{
            return this->OSG::ImageFileType::restoreData( boost::python::ptr(pImage), buffer, memSize );
        }
    }
    
    ::OSG::UInt64 default_restoreData( ::OSG::Image * pImage, ::OSG::UChar8 const * buffer, ::OSG::Int32 memSize=-0x00000000000000001 ) const  {
        return OSG::ImageFileType::restoreData( boost::python::ptr(pImage), buffer, memSize );
    }

    virtual ::OSG::UInt64 storeData( ::OSG::Image const * pImage, ::OSG::UChar8 * buffer, ::OSG::Int32 memSize=-0x00000000000000001 ) const  {
        if( bp::override func_storeData = this->get_override( "storeData" ) )
            return func_storeData( boost::python::ptr(pImage), buffer, memSize );
        else{
            return this->OSG::ImageFileType::storeData( boost::python::ptr(pImage), buffer, memSize );
        }
    }
    
    ::OSG::UInt64 default_storeData( ::OSG::Image const * pImage, ::OSG::UChar8 * buffer, ::OSG::Int32 memSize=-0x00000000000000001 ) const  {
        return OSG::ImageFileType::storeData( boost::python::ptr(pImage), buffer, memSize );
    }

    virtual bool validateHeader( ::OSG::Char8 const * fileName, bool & implemented ) {
        if( bp::override func_validateHeader = this->get_override( "validateHeader" ) )
            return func_validateHeader( fileName, implemented );
        else{
            return this->OSG::ImageFileType::validateHeader( fileName, implemented );
        }
    }
    
    bool default_validateHeader( ::OSG::Char8 const * fileName, bool & implemented ) {
        return OSG::ImageFileType::validateHeader( fileName, implemented );
    }

    virtual bool write( ::OSG::Image const * pImage, ::OSG::Char8 const * fileName ) {
        if( bp::override func_write = this->get_override( "write" ) )
            return func_write( boost::python::ptr(pImage), fileName );
        else{
            return this->OSG::ImageFileType::write( boost::python::ptr(pImage), fileName );
        }
    }
    
    bool default_write( ::OSG::Image const * pImage, ::OSG::Char8 const * fileName ) {
        return OSG::ImageFileType::write( boost::python::ptr(pImage), fileName );
    }

    virtual bool write( ::OSG::Image const * pImage, ::std::ostream & os, ::std::string const & mimetype ) {
        if( bp::override func_write = this->get_override( "write" ) )
            return func_write( boost::python::ptr(pImage), boost::ref(os), mimetype );
        else{
            return this->OSG::ImageFileType::write( boost::python::ptr(pImage), boost::ref(os), mimetype );
        }
    }
    
    bool default_write( ::OSG::Image const * pImage, ::std::ostream & os, ::std::string const & mimetype ) {
        return OSG::ImageFileType::write( boost::python::ptr(pImage), boost::ref(os), mimetype );
    }

    virtual ::std::string determineMimetypeFromStream( ::std::istream & is ) {
            if( bp::override func_determineMimetypeFromStream = this->get_override( "determineMimetypeFromStream" ) )
                return func_determineMimetypeFromStream( boost::ref(is) ).as<std::string>();
            else{
                return this->OSG::ImageFileType::determineMimetypeFromStream( boost::ref(is) );
            }
        }
        
        ::std::string default_determineMimetypeFromStream( ::std::istream & is ) {
            return OSG::ImageFileType::determineMimetypeFromStream( boost::ref(is) );
        }

};

namespace
{

bp::list wrapGetSuffixList(OSG::ImageFileType& ift)
{
   std::list<std::string> list = ift.getSuffixList();
   bp::list python_list;

   typedef std::list<std::string>::iterator iter_type;
   for ( iter_type i = list.begin(); i != list.end(); ++i )
   {
      python_list.append(*i);
   }

   return python_list;
}

}

void register_ImageFileType_class(){

    { //::OSG::ImageFileType
        typedef bp::class_< ImageFileType_wrapper, boost::noncopyable > ImageFileType_exposer_t;
        ImageFileType_exposer_t ImageFileType_exposer = ImageFileType_exposer_t( "ImageFileType", bp::no_init );
        bp::scope ImageFileType_scope( ImageFileType_exposer );
        bp::scope().attr("OSG_READ_SUPPORTED") = (int)OSG::ImageFileType::OSG_READ_SUPPORTED;
        bp::scope().attr("OSG_WRITE_SUPPORTED") = (int)OSG::ImageFileType::OSG_WRITE_SUPPORTED;
        ImageFileType_exposer.def( bp::init< OSG::Char8 const *, OSG::Char8 const * *, OSG::UInt16, bp::optional< OSG::UInt32 > >(( bp::arg("mimeType"), bp::arg("suffixArray"), bp::arg("suffixByteCount"), bp::arg("flags")=(::OSG::UInt32)(::OSG::UInt32(::OSG::ImageFileType::OSG_READ_SUPPORTED)) )) );
        { //::OSG::ImageFileType::dump
        
            typedef void ( ::OSG::ImageFileType::*dump_function_type )(  ) ;
            
            ImageFileType_exposer.def( 
                "dump"
                , dump_function_type( &::OSG::ImageFileType::dump ) );
        
        }
        { //::OSG::ImageFileType::getMimeType
        
            typedef ::OSG::Char8 const * ( ::OSG::ImageFileType::*getMimeType_function_type )(  ) const;
            
            ImageFileType_exposer.def( 
                "getMimeType"
                , getMimeType_function_type( &::OSG::ImageFileType::getMimeType ) );
        
        }
        { //::OSG::ImageFileType::maxBufferSize
        
            typedef ::OSG::UInt64 ( ::OSG::ImageFileType::*maxBufferSize_function_type )( ::OSG::Image const * ) ;
            typedef ::OSG::UInt64 ( ImageFileType_wrapper::*default_maxBufferSize_function_type )( ::OSG::Image const * ) ;
            
            ImageFileType_exposer.def( 
                "maxBufferSize"
                , maxBufferSize_function_type(&::OSG::ImageFileType::maxBufferSize)
                , default_maxBufferSize_function_type(&ImageFileType_wrapper::default_maxBufferSize)
                , ( bp::arg("pImage") ) );
        
        }
        { //::OSG::ImageFileType::open
        
            typedef ::OSG::ImageBlockAccessorPtr ( ::OSG::ImageFileType::*open_function_type )( ::OSG::Char8 const * ) ;
            typedef ::OSG::ImageBlockAccessorPtr ( ImageFileType_wrapper::*default_open_function_type )( ::OSG::Char8 const * ) ;
            
            ImageFileType_exposer.def( 
                "open"
                , open_function_type(&::OSG::ImageFileType::open)
                , default_open_function_type(&ImageFileType_wrapper::default_open)
                , ( bp::arg("fileName") ) );
        
        }
        { //::OSG::ImageFileType::read
        
            typedef bool ( ::OSG::ImageFileType::*read_function_type )( ::OSG::Image *,::OSG::Char8 const * ) ;
            typedef bool ( ImageFileType_wrapper::*default_read_function_type )( ::OSG::Image *,::OSG::Char8 const * ) ;
            
            ImageFileType_exposer.def( 
                "read"
                , read_function_type(&::OSG::ImageFileType::read)
                , default_read_function_type(&ImageFileType_wrapper::default_read)
                , ( bp::arg("pImage"), bp::arg("fileName") ) );
        
        }
        { //::OSG::ImageFileType::read
        
            typedef bool ( ::OSG::ImageFileType::*read_function_type )( ::OSG::Image *,::std::istream &,::std::string const & ) ;
            typedef bool ( ImageFileType_wrapper::*default_read_function_type )( ::OSG::Image *,::std::istream &,::std::string const & ) ;
            
            ImageFileType_exposer.def( 
                "read"
                , read_function_type(&::OSG::ImageFileType::read)
                , default_read_function_type(&ImageFileType_wrapper::default_read)
                , ( bp::arg("pImage"), bp::arg("is"), bp::arg("mimetype") ) );
        
        }
        { //::OSG::ImageFileType::restore
        
            typedef ::OSG::UInt64 ( *restore_function_type )( ::OSG::Image *,::OSG::UChar8 const *,::OSG::Int32 );
            
            ImageFileType_exposer.def( 
                "restore"
                , restore_function_type( &::OSG::ImageFileType::restore )
                , ( bp::arg("pImage"), bp::arg("buffer"), bp::arg("memSize")=(::OSG::Int32)(-0x00000000000000001) ) );
        
        }
        { //::OSG::ImageFileType::restoreData
        
            typedef ::OSG::UInt64 ( ::OSG::ImageFileType::*restoreData_function_type )( ::OSG::Image *,::OSG::UChar8 const *,::OSG::Int32 ) const;
            typedef ::OSG::UInt64 ( ImageFileType_wrapper::*default_restoreData_function_type )( ::OSG::Image *,::OSG::UChar8 const *,::OSG::Int32 ) const;
            
            ImageFileType_exposer.def( 
                "restoreData"
                , restoreData_function_type(&::OSG::ImageFileType::restoreData)
                , default_restoreData_function_type(&ImageFileType_wrapper::default_restoreData)
                , ( bp::arg("pImage"), bp::arg("buffer"), bp::arg("memSize")=(::OSG::Int32)(-0x00000000000000001) ) );
        
        }
        { //::OSG::ImageFileType::store
        
            typedef ::OSG::UInt64 ( *store_function_type )( ::OSG::Image const *,::OSG::Char8 const *,::OSG::UChar8 *,::OSG::Int32 );
            
            ImageFileType_exposer.def( 
                "store"
                , store_function_type( &::OSG::ImageFileType::store )
                , ( bp::arg("pImage"), bp::arg("mimeType"), bp::arg("buffer"), bp::arg("memSize")=(::OSG::Int32)(-0x00000000000000001) ) );
        
        }
        { //::OSG::ImageFileType::store
        
            typedef ::OSG::UInt64 ( ::OSG::ImageFileType::*store_function_type )( ::OSG::Image const *,::OSG::UChar8 *,::OSG::Int32 ) ;
            
            ImageFileType_exposer.def( 
                "store"
                , store_function_type( &::OSG::ImageFileType::store )
                , ( bp::arg("pImage"), bp::arg("buffer"), bp::arg("memSize")=(::OSG::Int32)(-0x00000000000000001) ) );
        
        }
        { //::OSG::ImageFileType::storeData
        
            typedef ::OSG::UInt64 ( ::OSG::ImageFileType::*storeData_function_type )( ::OSG::Image const *,::OSG::UChar8 *,::OSG::Int32 ) const;
            typedef ::OSG::UInt64 ( ImageFileType_wrapper::*default_storeData_function_type )( ::OSG::Image const *,::OSG::UChar8 *,::OSG::Int32 ) const;
            
            ImageFileType_exposer.def( 
                "storeData"
                , storeData_function_type(&::OSG::ImageFileType::storeData)
                , default_storeData_function_type(&ImageFileType_wrapper::default_storeData)
                , ( bp::arg("pImage"), bp::arg("buffer"), bp::arg("memSize")=(::OSG::Int32)(-0x00000000000000001) ) );
        
        }
        { //::OSG::ImageFileType::validateHeader
        
            typedef bool ( ::OSG::ImageFileType::*validateHeader_function_type )( ::OSG::Char8 const *,bool & ) ;
            typedef bool ( ImageFileType_wrapper::*default_validateHeader_function_type )( ::OSG::Char8 const *,bool & ) ;
            
            ImageFileType_exposer.def( 
                "validateHeader"
                , validateHeader_function_type(&::OSG::ImageFileType::validateHeader)
                , default_validateHeader_function_type(&ImageFileType_wrapper::default_validateHeader)
                , ( bp::arg("fileName"), bp::arg("implemented") ) );
        
        }
        { //::OSG::ImageFileType::write
        
            typedef bool ( ::OSG::ImageFileType::*write_function_type )( ::OSG::Image const *,::OSG::Char8 const * ) ;
            typedef bool ( ImageFileType_wrapper::*default_write_function_type )( ::OSG::Image const *,::OSG::Char8 const * ) ;
            
            ImageFileType_exposer.def( 
                "write"
                , write_function_type(&::OSG::ImageFileType::write)
                , default_write_function_type(&ImageFileType_wrapper::default_write)
                , ( bp::arg("pImage"), bp::arg("fileName") ) );
        
        }
        { //::OSG::ImageFileType::write
        
            typedef bool ( ::OSG::ImageFileType::*write_function_type )( ::OSG::Image const *,::std::ostream &,::std::string const & ) ;
            typedef bool ( ImageFileType_wrapper::*default_write_function_type )( ::OSG::Image const *,::std::ostream &,::std::string const & ) ;
            
            ImageFileType_exposer.def( 
                "write"
                , write_function_type(&::OSG::ImageFileType::write)
                , default_write_function_type(&ImageFileType_wrapper::default_write)
                , ( bp::arg("pImage"), bp::arg("os"), bp::arg("mimetype") ) );
        
        }
        ImageFileType_exposer.staticmethod( "restore" );
        ImageFileType_exposer.staticmethod( "store" );
        ImageFileType_exposer.def("getSuffixList", wrapGetSuffixList);
        { //::OSG::ImageFileType::determineMimetypeFromStream
                
                    typedef ::std::string ( ::OSG::ImageFileType::*determineMimetypeFromStream_function_type )( ::std::istream & ) ;
                    typedef ::std::string ( ImageFileType_wrapper::*default_determineMimetypeFromStream_function_type )( ::std::istream & ) ;
                
                    ImageFileType_exposer.def( 
                        "determineMimetypeFromStream"
                        , determineMimetypeFromStream_function_type(&::OSG::ImageFileType::determineMimetypeFromStream)
                        , default_determineMimetypeFromStream_function_type(&ImageFileType_wrapper::default_determineMimetypeFromStream)
                        , ( bp::arg("is") ) );
                
                }
    }

}
